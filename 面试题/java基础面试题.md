# Java基础面试题

## 基础语法

### Java有哪些数据类型

![image-20230423143726508](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423143726508.png)

### 访问修饰符的区别

```
private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

public : 对所有类可见。使用对象：类、接口、变量、方法
```

![image-20230423143840112](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423143840112.png)

### &和&&的区别

```
&运算符有两种用法：
1. 按位与
2. 逻辑与

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。
```

### final finally finalize区别

```
- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。
```

### this与super的区别

```
- super:　它引用当前对象的直接父类中的成员，this：它代表当前对象名
- super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法
- super()和this()均需放在构造方法内第一行
- this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有- - super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过
- this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块
- 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字
```

### break ,continue ,return 的区别及作用

```
break 结束当前的循环体

continue 跳出本次循环，继续执行下次循环-

return 结束当前的方法，直接返回
```

### 抽象类和接口的对比

> 相同点

```
- 接口和抽象类都不能实例化
- 都位于继承的顶端，用于被其他类实现或继承
- 都包含抽象方法，其子类都必须重写这些抽象方法
```

> 不同点

| 参数       | 抽象类                                                       | 接口                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 声明       | 抽象类使用abstract关键字声明                                 | 接口使用interface关键字声明                                  |
| 实现       | 子类使用extends关键字来继承抽象类。如果一个类继承了抽象类，那么该子类必须实现抽象类的所有抽象方法。 | 子类使用implements关键字来实现接口。如果一个类实现了接口，那么该子类必须实现父接口的所有方法。 |
| 构造器     | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 访问修饰符 | 抽象类中的方法可以是任意访问修饰符                           | 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected |
| 字段声明   | 抽象类的字段声明可以是任意的                                 | 接口的字段默认都是 static 和 final 的                        |
| 多继承     | 一个类最多只能继承一个抽象类                                 | 一个类可以实现多个接口                                       |

### 重载（Overload）和重写（Override）的区别

```
重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分

重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写
```

### 构造器（constructor）是否可被重写（override）

```
构造器不能被继承，因此不能被重写，但可以被重载。
```

### == 和 equals 的区别

```
== : 它的作用是判断两个对象的内存地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)

equals() : 它的作用也是判断两个对象是否相等。有两种使用情况：
情况1：类没有覆盖 equals() 方法，等价于通过“==”比较这两个对象。
情况2：类覆盖了 equals() 方法。一般我们都覆盖 equals() 方法来判断两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)
```

## IO流

### IO 流分类

```
- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以分为字节流和字符流；
- 按照流的角色划分，可以分为节点流和处理流

InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流
```

### 同步与异步的区别

```
同步： 同步就是发起一个请求，被调用者未处理完请求之前，调用不返回。

异步： 异步就是发起一个请求，立刻得到被调用者的响应表示已接收到请求，但是被调用者并没有返回请求处理结果，此时我们可以处理其他的请求，被调用者通过事件和回调等机制来通知调用者其返回结果。

同步和异步的区别在于调用者需不需要等待被调用者的处理结果
```

### 阻塞和非阻塞

```
阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当返回结果才能继续。

非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

阻塞和非阻塞的区别在于调用者的线程需不需要挂起
```

### BIO,NIO,AIO 有什么区别

> BIO

```
BIO（jdk1.4之前）：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它基于流模型实现，一个连接一个线程，客户端有连接请求时，服务器端就需要启动一个线程进行处理，线程开销大。伪异步IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。它的特点是模式简单使用方便，但并发处理能力低，容易成为应用性能的瓶颈。BIO是面向流的，BIO的Stream是单向的
```

> NIO

```
NIO（jdk1.4 之后  linux的多路复用技术 select 模式）：Non IO 同步非阻塞 IO，是传统 IO 的升级，提供了 Channel、Selector、Buffer 等新的抽象，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO是面向缓冲区的，NIO的channel是双向的。

NIO 能解决什么问题？

通过一个固定大小的线程池，来负责管理工作线程，避免频繁创建、销毁线程的开销，这是我们构建并发服务的典型方式。
NIO 则是利用了单线程轮询事件的机制，通过高效地定位就绪的 Channel，来决定做什么，仅仅 select 阶段是阻塞的，可以有效避免大量客户端连接时，频繁线程切换带来的问题，应用的扩展能力有了非常大的提高
```

> AIO

```
Asynchronous IO 异步非堵塞 IO，是 NIO 的升级，异步 IO 的操作基于事件和回调机制，性能是最好的。底层实现是通过epoll的I/O多路复用机制
```

## 反射

### 什么是反射机制

```
JAVA反射机制是在程序运行过程中，对于任意一个类或对象，都能够知道这个类或对象的所有属性和方法，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制
```

### 反射机制优缺点

```
优点 ：运行期类型的判断，动态加载类，提高代码的灵活性。

缺点：性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多
```

### 获取class对象的三种方式

```
- Class.forName(全类名) ——>源代码阶段
  Class clazz = Class.forName("com.yolo.ClassDemo.Student");
  
- 类名.class ——>Class对象阶段
  Class<Student> clazz2 = Student.class;
  
- 对象名.getClass() ——>运行时阶段
  Student student = new Student();
  Class<? extends Student> clazz3 = student.getClass();
```

### 反射机制的应用场景

```
1、我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序
2、Spring框架也用到很多反射机制，最经典的就是xml的配置模式
	- 将程序内所有 XML 或 Properties 配置文件加载入内存中
	- Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息
	- 使用反射机制，根据这个字符串获得某个类的Class实例
	- 动态配置实例的属性
```

## 网络编程

### TCP/IP的五层体系结构分别是什么

> **应用层**

```
应用层协议定义的是应用进程间的通信和交互的规则，例如：域名系统 DNS、 HTTP 协议、SMTP 协议
```

> **运输层**

```
运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务

运输层主要使用一下两种协议
传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。
用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）
```

> **网络层**

```
网络层的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送
```

> **数据链路层**

```
两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议
```

> **物理层**

```
在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异
```

### TCP和UDP的区别

```
1、TCP ：面向连接，UDP ：面向无连接
2、TCP ：传输效率低，UDP ：传输效率高(有大小限制，一次限定在64kb之内)
3、TCP：可靠，UDP ：不可靠
```

### 四层协议，五层协议和七层协议的关系

```
- TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层

- 层协议的体系结构主要包括：应用层、运输层、网络层，数据链路层和物理层

- OSI七层协议模型主要包括是：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）
```

![image-20230423153141927](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423153141927.png)

### TCP的三次握手四次挥手的过程

> **三次握手**
>
> 三次握手的本质是确认通信双方收发数据的能力

![image-20230423154311812](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423154311812.png)

```
第一次握手：客户端要向服务端发起连接请求
第二次握手：服务端收到客户端发过来的报文后，知道这是一个连接请求，然后给客户端进行回复
第三次握手：客户端收到服务端的回复后知道了服务端同意了这次连接，然后客户端再回复一段报文给服务端，当服务端收到报文后，客户端和服务端通过TCP建立了连接
```

> **四次挥手**
>
> 四次挥手的目的是关闭一个连接

![image-20230423154323551](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423154323551.png)

```
第一次挥手：客户端向服务端发出连接释放报文
第二次挥手：服务端收到客户端发的报文后给客户端回复确认报文
第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文
第四次挥手：客户端收到服务端发的报文后，向服务端发出确认报文，而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些
```

### 为什么TCP连接的时候是3次，关闭的时候却是4次？

```
因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了，服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。
```



### GET和POST区别

```
GET：从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。
POST：向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。
PUT：英文含义是放置，也就是向服务器新添加数据，就是所谓的增。
DELETE：从字面意思也能看出，这种方式就是删除服务器数据的过程
```

|               | Get                                                          | Post                                           |
| ------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| 安全性        | Get是不安全的，因为在传输过程，数据被放在请求的URL中         | Post的所有操作对用户来说都是不可见的，相对安全 |
| url数据大小   | Get请求提交的url中的数据受浏览器和服务器的限制，防止有人恶意发送请求 | Post请求url数据没有大小限制                    |
| 表单字符集    | Get限制Form表单的数据集的值必须为ASCII字符                   | Post支持整个ISO10646字符集                     |
| TCP数据包数量 | GET产生一个TCP数据包                                         | POST产生两个TCP数据包                          |
| 执行效率      | Get执行效率比Post快                                          |                                                |

### Session、Cookie和Token的主要区别

**HTTP协议本身是无状态的。什么是无状态呢，即服务器无法判断用户身份。**

> **什么是cookie**

```
cookie是由Web服务器保存在用户浏览器上的小文件（key-value格式），包含用户相关的信息。客户端向服务器发起请求，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户身份
```

> **什么是session**

```
session是依赖Cookie实现的。session是服务器端对象

session 是浏览器和服务器会话过程中，服务器分配的一块储存空间。服务器默认为浏览器在cookie中设置 sessionid，浏览器在向服务器请求过程中传输 cookie 包含 sessionid ，服务器根据 sessionid 获取出会话中存储的信息，然后确定会话的身份信息
```

> **什么是Token**

```
Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生

Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码

使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮
```

> **cookie与session区别**

```
存储位置与安全性：cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高；

存储空间：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，session无此限制

占用服务器资源：session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。
```

> **session与token区别**

```
session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；

session存储在服务器端，token存储在客户端

token提供认证和授权功能，作为身份认证，token安全性比session好；

session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）
```

### Servlet接口中有哪些方法

```
Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：

- void init(ServletConfig config) throws ServletException
- void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException
- void destory()
- java.lang.String getServletInfo()
- ServletConfig getServletConfig()
```

### Servlet生命周期

```
Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；

请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；

当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。

init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源
```

### Servlet是线程安全的吗

```
Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。 

解决的办法是尽量不要在实现servlet接口的类中定义实例变量，而是要把变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。

注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。
```

### Servlet执行流程

```
1、web客户向Servlet容器发出HTTP请求;
2、Servlet容器解析web的HTTP请求;
3、Servlet容器创建一个HttpRequest对象，在这个对象中封装了http请求信息;
4、Servlet容器创建一个HttpResponse对象;
5、Servlet容器（如果访问的该servlet不是在服务器启动时创建的，则先创建servlet实例并调用init()方法初始化对象）调用HttpServlet的service()方法，把HttpRequest和HttpResponse对象为service方法的参数传给HttpServlet对象;
6、HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息;
7、HttpServlet调用HttpResponse的有关方法，生成响应数据;
8、Servlet容器把HttpServlet的响应结果传给web客户
```

### forward和redirect的区别

```
1、地址栏不同
	转发是发生在服务器的，转发是由服务器进行跳转的，浏览器的地址栏是没有发生变化的，实现转发只是一次的http请求
	重定向是由浏览器进行跳转的，浏览器的地址会发生变化的，由浏览器进行的页面跳转，实现重定向会发出两个http请求，request域对象是无效的，因为它不是同一个request对象
	
2、访问范围不一样
	转发是服务器跳转只能去往当前web应用的资源
	重定向是浏览器跳转，可以去往任何的资源
	
3、传递数据的类型不同
	转发的request对象可以传递各种类型的数据，包括对象
	重定向只能传递字符串	
	
4、跳转的时间不同
	转发：执行到跳转语句时就会立刻跳转
	重定向：整个页面执行完之后才执行跳转
  
典型的应用场景：
forward一般用于用户登陆的时候根据角色转发到相应的模块。 
redirect一般用于用户注销登陆时返回主页面和跳转到其它的网站等  
```

### 如何解决跨域问题

```
CORS全称Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者同域名不同端口的资源时，就会发出跨域请求。如果此时另一个资源不允许其进行跨域资源访问，那么访问就会遇到跨域问题。

跨域指的是浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成的，是浏览器对JavaScript 施加的安全限制

所谓同源指的是：协议、域名、端口号都相同，只要有一个不相同，那么都是非同源

解决方案：
    1：使用ajax的jsonp
    2：nginx 转发：利用nginx反向代理，将请求分发到部署相应项目的tomcat服务器，当然也不存在跨域问题。
    3：使用cors：写一个配置类实现WebMvcConfigurer接口或者配置FilterRegistrationBean
```

### 什么是 CSRF 攻击？如何防御CSRF 攻击

```
CSRF（Cross-site request forgery） 跨站请求伪造。CSRF 攻击是在受害者毫不知情的情况下，以受害者名义伪造请求发送给受攻击站点，从而在受害者并未授权的情况下执行受害者权限下的各种操作。

目前防御 CSRF 攻击主要有三种策略：
	1、验证 HTTP Referer 字段
	2、在请求地址中添加 token 并验证
	3、在 HTTP 头中自定义属性并验证
```

### http和https的基本概念

```
- HTTP:
	是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于计算机之间传输文字，图片，音频，视频等超文本数据的协议，它可以使浏览器更加高效，使网络传输减少
- HTTPS:
	是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护

- HTTPS协议的主要作用：
    建立一个信息安全通道，来保证数据传输的安全
    确认网站的真实性    
```

### http和https的区别

| 区别     | HTTP                                                         | HTTPS                                                        |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 协议     | 运行在 TCP 之上，明文传输，**客户端与服务器端都无法验证对方的身份** | 身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， **是添加了加密和认证机制的 HTTP**。 |
| 端口     | 80                                                           | 443                                                          |
| 资源消耗 | 较少                                                         | 由于加解密处理，会消耗更多的 CPU 和内存资源                  |
| 证书     | 无需证书                                                     | 需要证书，而证书一般需要向认证机构购买                       |
| 加密机制 | 无                                                           | 共享密钥加密和公开密钥加密并用的混合加密机制                 |
| 安全性   | 弱                                                           | 由于加密机制，安全性强                                       |

### 一次完整的HTTP请求所经历几个步骤

```
1、根据域名和 DNS 解析到服务器的IP地址 (DNS + CDN)
2、通过ARP协议获得IP地址对应的物理机器的MAC地址
3、浏览器对服务器发起 TCP 3 次握手
4、建立 TCP 连接后发起 HTTP 请求报文
5、服务器响应 HTTP 请求，将响应报文返回给浏览器
6、短连接情况下，请求结束则通过 TCP 四次挥手关闭连接，长连接在没有访问服务器的若干时间后，进行连接的关闭
7、浏览器得到响应信息中的 HTML 代码， 并请求 HTML 代码中的资源（如js、css、图片等）
8、浏览器对页面进行渲染并呈现给用户
```

### 常用HTTP状态码是怎么分类的

| 状态码 | 类别                             | 描述                                           |
| ------ | -------------------------------- | ---------------------------------------------- |
| 1xx    | Informational（信息状态码）      | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2xx    | Success（成功状态码）            | 成功，操作被成功接收并处理                     |
| 3xx    | Redirection（重定向状态码）      | 重定向，需要进一步的操作以完成请求             |
| 4xx    | Client Error（客户端错误状态码） | 客户端错误，请求包含语法错误或无法完成请求     |
| 5xx    | Server Error（服务器错误状态码） | 服务器错误，服务器在处理请求的过程中发生了错误 |

### HTTP1.0和HTTP1.1的区别

```
1、缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

2、带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

3、错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

4、Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

5、长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。
```

## 常用API

### 自动装箱与拆箱

```
装箱：将基本类型用它们对应的引用类型包装起来；原理：Integer.valueOf() 方法
拆箱：将包装类型转换为基本数据类型；原理：Integer.intValue() 方法
```

### 包装类型的常量池技术了解吗

```
Java 基本类型的包装类的大部分都实现了常量池技术。

Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。
```

### Integer a= 127 与 Integer b = 127相等吗

```
对于对象引用类型：==比较的是对象的内存地址。对于基本数据类型：==比较的是值。

如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false
```

### String的创建机理是什么？什么是字符串常量池？

```
创建机理：由于String在Java世界中使用过于频繁，为了提高内存的使用率，避免开辟多块空间存储相同的字符串，引入了字符串常量池（字符串常量池位于堆内存中）。

其运行机制是：在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。
```

### String 是最基本的数据类型吗

```
不是。Java 中的基本数据类型只有 8 个，除了基本类型，剩下的都是引用类型

基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，如果要描述一段文本，就需要使用 char 类型数组，但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，使用更加简便
```

### String s = new String(“abc”);创建了几个字符串对象

```
当JVM遇到上述代码时，会先检索常量池中是否存在“abc”，如果不存在“abc”这个字符串，则会先在常量池中创建这个字符串。然后再执行new操作，在堆内存中创建一个String对象，对象的引用赋值给s。此过程创建了2个对象。

当然，如果检索常量池时发现已经存在了对应的字符串，那么只会在堆内创建一个新的String对象，此过程只创建了1个对象。
```

### String str="i"与 String str=new String(“i”)一样吗

```
不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中
```

### String为什么设计为final

```
1、final修饰的String类，代表了String类的不可被继承。String类一旦在常量池（节省资源，提高效率，因为如果已经存在这个常量便不会再创建，直接拿来用）被创建，是无法修改的，即便你在后面拼接一些其他字符，也会把新生成的字符串存到另外一个地址
2、线程安全，多线程下对资源进行写操作是有风险的，不可变对象不能被写，所以线程安全
3、因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算，这就是HashMap中的键往往都使用字符串的原因之一
```

### 在使用 HashMap 的时候，用 String 做 key 有什么好处

```
HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快
```

### String和StringBuffer、StringBuilder的区别

```
1、可变性：String是final修饰的字符数组，是不可变的。StringBuilder与StringBuffer这两种对象都是可变的
2、线程安全：String中的对象是不可变的，线程安全。StringBuffer对方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的
3、性能：StringBuilder > StringBuffer > String

使用场景
1、在字符串内容不经常发生变化的业务场景，优先使用String类，例如常量声明、少量的字符串拼接操作等。
2、在单线程环境下，频繁地进行字符串的操作，建议使用StringBuilder，例如SQL语句拼装、JSON封装等
3、在多线程环境下，频繁地进行字符串的操作，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装
```

### String 类的常用方法都有那些

```java 
indexOf()：返回指定字符的索引。
charAt()：返回指定索引处的字符。
replace()：字符串替换。
trim()：去除字符串两端空白。
split()：分割字符串，返回一个分割后的字符串数组。
getBytes()：返回字符串的 byte 类型数组。
length()：返回字符串长度。
toLowerCase()：将字符串转成小写字母。
toUpperCase()：将字符串转成大写字符。
substring()：截取字符串。
equals()：字符串比较。
```

## 异常

### Java异常架构

```java 
- Throwable
    - Error(错误)
    	- Virtual MachineError（虚拟机运行错误）
    	- NoClassDefFoundError（类定义错误）
    	- OutOfMemoryError(内存不足错误)
    	- StackOverflowError(栈溢出错误)
    - Exception(异常)
    	- 运行时异常
    	- 编译时异常
```

### Error 和 Exception 的区别

```
Error 是程序正常运行中，不大可能出现的错误，通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等。编译器不会对这类错误进行检测，应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身是无法恢复的；

Exception 是程序正常运行中，可以预料的意外情况，通常遇到这种异常，应对其进行处理，使应用程序可以继续正常运行
```

### 什么是受检异常与非受检异常

> 受检异常

编译器要求必须处理的异常。**Exception 中除 RuntimeException 及其子类之外的异常都属于受检异常**。编译器会检查此类异常，也就是说当编译器检查到应用中的某处可能会此类异常时，将会提示你处理本异常——要么使用try-catch捕获，要么使用方法签名中用 throws 关键字抛出，否则编译不通过

> 非受检异常

编译器不会进行检查并且不要求必须处理的异常，也就说当程序中出现此类异常时，即使我们没有try-catch捕获它，也没有使用throws抛出该异常，编译也会正常通过。**该类异常包括运行时异常（RuntimeException及其子类）和错误（Error）**

### 什么是运行时异常，编译时异常

> 运行时异常

**定义**：RuntimeException 类及其子类。

**特点**：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既"没有通过throws声明抛出它"，也"没有用try-catch语句捕获它"，还是会编译通过。比如NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常。此类异常属于非受检异常，在程序中可以选择捕获，抛出，也可以不处理，此类异常一般是由程序逻辑错误引起的，需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生

> 编译时异常

**定义**: Exception 中除 RuntimeException 及其子类之外的异常。

**特点**: Java 编译器会检查它。如果程序中出现此类异常，比如 ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常），要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。在程序中，通常不会自定义该类异常，而是直接使用系统提供的异常类。

### 如何选择异常类型

![image-20230423164504272](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423164504272.png)

### 运行时异常和受检异常的区别

```
RuntimeException异常和受检异常之间的区别：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检异常，否则就选择非受检异常(RuntimeException)。一般来讲，如果没有特殊的要求，我们建议使用RuntimeException异常。
```

### throw 和 throws 的区别

```
1、throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常
2、throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。调用该方法的方法必须包含可处理异常的代码，否则也要在方法声明中用 throws 关键字声明相应的异常。
```

### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗

```
会执行，在 return 前执行。

注意：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误
```

