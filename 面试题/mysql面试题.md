# MySQL面试题

## 基础

### 数据库三大范式是什么

```
第一范式：每个列都不可以再拆分

第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。

三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键
```

### SQL的几种连接查询方式

```mysql
一、内连接（inner join）
查出的是两张表的交集，两张表都有的才查出来
SQL：
select * from 表A inner join 表B on 判断条件;
select * from 表A, 表B where 判断条件;

二、外连接
1、左外连接（left join）以左表为主表（查询全部）， 右表为辅表（没有的显示null）
SQL：select * from 表A left join 表B on 判断条件;
2、右外连接（right join）
以右表为主表（查询全部）， 左表为辅表（没有的显示null）
SQL：select * from 表A right join 表B on 判断条件;

三、全连接（full join）
两个表的所有数据都展示出来
SQL：select * from 表A full join 表B on 判断条件;

四、联合(合并)查询（union）
MySQL 不识别 FULL join，所以可以通过 union 来实现
select a.*, ad.* from test_a as a left join test_a_description as ad on a.id=ad.parent_id
union
select a.*, ad.* from test_a as a right join test_a_description as ad on a.id=ad.parent_id;
```

### sql语句的执行顺序

```
from > where > group by > having > 聚合函数 > distinct > order by > limit > select
```

### drop、delete、truncate的区别

```
drop delete truncate 在mysql中都表示删除
    -1 delete和truncate只删除表的数据不删除表的结构
    -2 delete这个语句是dml，这个操作需要在事务提交后才可以生效
    -3 truncate和drop 的ddl，操作立即生效
    -4 速度：drop > truncate > delete
```

### varchar和char有什么区别

```
char是一个定长字段,假如申请了 char(10) 的空间,那么无论实际存储多少内容.该字段都占用10个字符,
而varchar是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用
了多长的空间
    
在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用char,否则应该
尽量使用varchar.例如存储用户MD5加密后的密码,则应该使用char    
```

### varchar(10)和int(10)代表什么含义

```
varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度
    
而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示    
```

### 字段为什么要求定义为not null

```
null值会占用更多的字节,且会在程序中造成很多与预期不符的情况
```

### SQL查询的基本原理

```
单表查询：根据WHERE条件过滤表中的记录，形成中间表（这个中间表对用户是不可见的）；然后根据SELECT的选择列选择相应的列进行返回最终结果。

两表连接查询：对两表求积（笛卡尔积）并用ON条件和连接连接类型进行过滤形成中间表；然后根据WHERE条件过滤中间表的记录，并根据SELECT指定的列返回查询结果。

多表连接查询：先对第一个和第二个表按照两表连接做查询，然后用查询结果和第三个表做连接查询，以此类推，直到所有的表都连接上为止，最终形成一个中间的结果表，然后根据WHERE条件过滤中间表的记录，并根据SELECT指定的列返回查询结果。理解SQL查询的过程是进行SQL优化的理论依据
```

## 存储引擎

### MySQL存储引擎种类

```
Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。

MyISAM引擎(原本MySQL的默认引擎)：不提供事务的支持，也不支持行级锁和外键。(mysql 5.5 版本之后默认存储引擎变为Innodb)

MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高
    
1. InnoDB : 支持事务, MySQL5.5版本之后, 默认的存储引擎,支持行级锁，支持外键，不支持全文索引，支持集群
2. MyISAM : 不支持事务，不支持外键，不支持行级锁，支持全文索引，效率高，不支持集群
3. Memory : 速度快,最不安全。小量快速访问的数据，不支持行级锁，不支持外键，不支持集群    
```

### MyISAM与InnoDB区别

|                                                              | Innodb                                               | MyISAM                                                       |
| ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| **存储结构**                                                 | 每张表都保存在同一个数据文件中                       | 每张表被存放在三个文件：表定义文件、数据文件、索引文件       |
| **数据和索引存储方式**                                       | 数据和索引是集中存储的，查询时做到覆盖索引会非常高效 | 数据和索引是分开存储的，索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据 |
| 记录存储顺序                                                 | 按主键大小有序插入                                   | 按记录插入顺序保存                                           |
| **索引**                                                     | 聚簇索引                                             | 非聚簇索引                                                   |
| 索引的实现方式                                               | B+树索引，Innodb 是索引组织表                        | B+树索引，myisam 是堆表                                      |
| **全文索引**                                                 | 不支持                                               | 支持                                                         |
| **哈希索引**                                                 | 支持                                                 | 不支持                                                       |
| **外键**                                                     | 支持                                                 | 不支持                                                       |
| **事务**                                                     | 支持                                                 | 不支持                                                       |
| **锁粒度**（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 行级锁定、表级锁定，锁定力度越小并发能力越高         | 表级锁定                                                     |
| SELECT                                                       |                                                      | MyISAM更优                                                   |
| select count(*)                                              |                                                      | myisam更快，因为myisam内部维护了一个计数器，可以直接调取。   |
| INSERT、UPDATE、DELETE                                       | InnoDB更优                                           |                                                              |

### 存储引擎选择

```
MyISAM：适用于管理非事务表，它提供高速存储和检索， 以及全文搜索能力的场景。比如博客系统、新闻门户网站。

InnoDB：适用于更新操作频繁，或者要保证数据的完整性，并发量高，支持事务和外键的场景。比如OA自动化办公系统。

如果没有特别的需求，使用默认的Innodb即可
```

## 索引

### 什么是索引,优缺点,分类

```
索引(index)：是帮助mysql高效获取数据的数据数据结构，索引的实现通常使用B+树或hash表
    
优点：
    可以大大加快数据的检索速度
    通过使用索引，可以在查询的过程中，使用优化器，提高系统的性能
缺点：
    对表进行插入，修改，删除的时候索引也要动态维护，会降低增/删/改的执行效率
    索引需要占物理空间

分类：    
	A. 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值，一个表允许多个列创建普通索引
	B. 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引
	C. 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键
	D. 组合索引: 就是将单列索引进行组合
	E. 外键索引: 只有 InnoDB 引擎支持外键索引, 用来保证数据的一致性、完整性和实现级联操作
	F. 全文索引: 是目前搜索引擎使用的一种关键技术，MyISAM存储引擎才有全文索引   
```

### 索引的数据结构（B+树，Hash）

> B+树数据结构

![image-20230423110113717](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423110113717.png)

- **从根节点到叶节点的所有路径都具有相同的长度**
- **所有数据信息都存储在叶子节点，非叶子节点仅作为叶节点的索引存在**
- **叶子节点通过指针连在一起**
- 根节点至少拥有两个子树
- 每个树节点最多拥有M个子树
- 每个树节点(除了根节点)拥有至少M/2个子树

****

> 哈希索引

类似于数据结构中简单实现的HASH表（散列表）一样，当我们在MySQL中用哈希索引时，主要就是通过Hash算法，将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储

![image-20230423110556223](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423110556223.png)

### 数据库为什么使用B+树而不是B树

```
1、B+树的叶子节点存储了所有的数据，非叶子节点中存储的是比较关键字。而B树所有的节点都会存储数据。B+树的叶子节点之间存在一个指针连接，B树不存在指针连接。B+树所有的数据都存储在叶子节点，那么顺着叶子节点从左往右即可完成对数据的遍历，极大了简化了排序操作

2、B树只适合随机检索，而B+树同时支持随机检索和顺序检索
    
3、B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低
   
4、B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。
    
5、增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率
```

### 索引算法有哪些

```
BTree算法:
	BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。

Hash算法：
    Hash算法只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到叶子节点这样多次IO访问，所以检索效率远高于BTree索引    
```

### 创建索引的原则

```
1、为常作为查询条件的字段建立索引，where子句中的列
2、为经常需要排序、分组操作的字段建立索引
3、更新频繁字段不适合创建索引
4、对于定义为text、image和bit的数据类型的列不要建立索引
5、非空字段  
6、不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
7、不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长
```

### MySQL使用自增主键的好处

```
1. 自增主键按顺序存放，增删数据速度快，对于检索非常有利；
2. 数字型，占用空间小，易排序；
3. 使用整形才可以使用AUTO_INCREAMENT，不用担心主键重复问题
```

### 什么是聚簇索引

```
聚簇索引：将数据与索引放到了一块，索引结构的叶子节点存储了行数据，找到索引也就找到了数据

非聚簇索引：将数据与索引分开存储，索引结构的叶子节点存储的是行数据的地址
    
聚簇索引的优点:
	数据访问更快。聚族索引将索引和数据保存在同一个B+树中，因此从聚族索引中获取数据通常比非聚族索引中查找更快
    当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。
    使用覆盖索引扫描的查询可以直接使用节点中的主键值    

聚簇索引的缺点:
	插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能
    更新主键的代价很高，因为将会导致被更新的行移动
    通过辅助索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据    
```

### 联合索引数据结构和实现原理

> 联合索引

MySQL可以使用多个字段组合建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引

> 实现原理

![image-20230423112429266](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423112429266.png)

如上图所示他们是按照a来进行排序，在a相等的情况下，才按b来排序。

因此，我们可以看到a是有序的1，1，2，2，3，3。而b是一种全局无序，局部相对有序状态！什么意思呢？

从全局来看，b的值为1，2，1，4，1，2，是无序的，因此直接执行`b = 2`这种查询条件没有办法利用索引。

从局部来看，当a的值确定的时候，b是有序的。例如a = 1时，b值为1，2是有序的状态。当a=2时候，b的值为1,4也是有序状态。因此，你执行`a = 1 and b = 2`是a,b字段能用到索引的。而你执行`a > 1 and b = 2`时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段用不上索引。

综上所示，最左匹配原则，在遇到范围查询的时候，就会停止匹配

### 什么是最左前缀原则

```
1、最左前缀原则，就是最左边的优先。指的是联合索引中，优先走最左边列的索引。对于多个字段的联合索引，如 index(a,b,c) 联合索引，则相当于创建了 a 单列索引，(a,b)联合索引，和(a,b,c)联合索引（但并不是建立了多个索引树）。mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间  

2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

3、如果建立的索引顺序是 (a,b) 那么直接采用 where b = 5 这种查询条件是无法利用到索引的，这一条最能体现最左匹配的特性
```

## 事务

### 什么是数据库事务

在我们使用数据库的时候,通常会围绕着一个业务功能, 展开一组操作, 这种操作中的每个小的步骤, 要么全部成功,要么全部失败. 那么就符合事务的概念。

### 数据库事务(ACID)

- 原子性(Atomicity)：事务是一个完整的操作，事务的各步操作是不可以拆分的，要么都执行，要么不执行
- 一致性(Consistency)：事务执行之前和执行之后都必须处于一致性状态(例如转账情况，不管如何转账一共还是一样的金额)
- 隔离性(Isolation)：多个事务之间互不干扰
- 永久性(Durability)：事务完成后，把数据永久保存到磁盘中

### 什么是脏读？不可重复读？幻读？

> 脏读

![image-20230423113457870](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423113457870.png)

脏读：	(读未提交) 当一个事务正在访问数据并且对数据进行修改的时候，还没有对修改的数据进行提交，然后另外一个事务访问到这个数据

> 不可重复读

![image-20230423113652209](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423113652209.png)

不可重复读： (读已提交)一个事务读取同一条记录2次，得到的结果不一致。这可能是两次查询过程中间，另一个事务更新了这条记录

> 幻读

![image-20230423113754941](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230423113754941.png)

幻读： (不可重复读)   幻读发生在两个完全相同的查询，得到的结果不一致。这可能是两次查询过程中间，另一个事务增加或者减少了行记录

> **不可重复度和幻读区别**
>
> 不可重复读的重点是修改，幻读的重点在于新增或者删除

### 什么是事务的隔离级别？MySQL的默认的隔离级别是什么？

**SQL 标准定义了四个隔离级别**

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |  ×   |     √      |  √   |
| REPEATABLE-READ  |  ×   |     ×      |  √   |
|   SERIALIZABLE   |  ×   |     ×      |  ×   |

- **READ-UNCOMMITTED(读未提交)**：最低的隔离级别，一个事务可以读取另一个事务更新但未提交的数据。**可能会导致脏读、不可重复读或幻读**。
- **READ-COMMITTED(读已提交)**：一个事务提交后才能被其他事务读取到，**可以阻止脏读，但是不可重复读或幻读仍有可能发生**。
- **REPEATABLE-READ(可重复读)**：对同一记录的多次读取结果都是一致的，除非数据是被本身事务所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

> 注意：
>
> MySQL 默认采用的 REPEATABLE_READ隔离级别，Oracle 默认采用的 READ_COMMITTED隔离级别
>
> InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别

### MVCC并发版本控制原理

```
MySQL可重复读是通过MVCC实现的

MVCC(Multi Version Concurrency Control的简称)，代表多版本并发控制。MVCC最大的优势：读不加锁，读写不冲突。在读多写少的应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能

MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较

InnoDB MVCC 实现原理

InnoDB 中 MVCC 的实现方式为：每一行记录都有两个隐藏列：DATA_TRX_ID、DATA_ROLL_PTR（如果没有主键，则还会多一个隐藏的主键列）
```

## 锁

### 按锁的粒度分类

在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁，默认采用行级锁

### 行级锁，表级锁和页级锁对比

> 行级锁

```
行级锁 行级锁是MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。

特点：锁定粒度最小，对当前操作的行记录加锁，发生锁冲突的概率最低，并发度也最高；加锁开销大，加锁慢；会出现死锁
```

> 表级锁

```
表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

特点：锁定粒度大，对当前操作的整张表加锁，发出锁冲突的概率最高，并发度最低；加锁开销小，加锁快；不会出现死锁；
```

> 页级锁

```
页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。

特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
```

### 共享锁和排他锁的区别

```
共享锁又称读锁,是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据

读取为什么要加读锁呢：防止数据在被读取的时候被别的线程加上写锁
使用方式：在需要执行的语句后面加上 for update就可以了

排他锁又称写锁，简称X锁。排他锁是悲观锁的一种实现。

若事务T对数据A加上排他锁，则只允许事务T读取和修改数据A，其他任何事务都不能再对A加任何类型的锁，直到事务T释放X锁。排他锁会阻塞所有的排他锁和共享锁
```

### 乐观锁和悲观锁是什么

```
悲观锁（适合多读场景）：假定会发生并发冲突，每次去查询数据的时候都认为别人会修改，每次查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制

乐观锁（适合多写场景）：假设不会发生并发冲突，每次去查询数据的时候都认为别人不会修改，所以不会上锁，在修改数据的时候才把事务锁起来。实现方式：乐观锁一般会使用版本号机制或CAS算法实现
```

## MySQL优化

### 如何定位及优化SQL语句的性能问题？

```
对于查询语句，最重要的优化方式就是使用索引。而执行计划，就是显示数据库引擎对于SQL语句执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等
```

### Explain 性能分析

```
概念：查看执行计划：使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理SQL 语句的。分析查询语句或是表结构的性能瓶颈。

作用：
	表的读取顺序
	数据读取操作的操作类型
	哪些索引可以使用
	哪些索引被实际使用
	表之间的引用
	每张表有多少行被优化器查询

语法：
	Explain + SQL 语句
```

### 常用SQL查询语句优化方法

```
- 不要使用select * from t，用具体的字段列表代替“*”，使用星号会降低查询效率，如果数据库字段改变，可能出现不可预知隐患
- 应尽量避免在where子句中使用!=或<>操作符，避免在where子句中字段进行null值判断，存储引擎将放弃使用索引而进行全表扫描
- 避免使用左模糊，左模糊查询将导致全表扫描
- IN语句查询时包含的值不应过多，否则将导致全表扫描
- 为经常作为查询条件的字段，经常需要排序、分组操作的字段建立索引
- or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)
- 在使用联合索引字段作为条件时，应遵循最左前缀原则
```

### 某个表有近千万数据，CRUD比较慢，如何优化

```
1、限定数据的查询范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：当用户在查询订单历史的时候，我们可以控制在一个月的范围内；
2、读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
3、缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
4、分库分表
```

### 分库分表

> **垂直分表**

```
垂直分表：垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库

适用场景：如果一个表中某些列常用，另外一些列不常用
优点：可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护
缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。对于应用层来说，逻辑算法增加开发成本。此外，垂直分区会让事务变得更加复杂
```

> **水平分表**

```
水平分表：保持数据表结构不变，通过某种策略进行存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量（表的行数超过200万行时，就会变慢）

注意：水平分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 
适用场景：支持非常大的数据量存储
优点：支持非常大的数据量存储
缺点：给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作；分片事务难以解决 ，跨库join性能较差，逻辑复杂
```

### SQL 注入漏洞产生的原因？如何防止

```
原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行

解决方案：使用PreparedStatement预编译执行者对象，用？作为占位符，用set方法进行赋值从1开始 
```

## MySQL原理

### SQL的生命周期？

```
1、连接器：客户端与数据库server层的连接器进行连接。连接器负责跟客户端建立连接、获取权限、维持和管理连接。

2、获得请求SQL：数据库进程拿到请求sql

3、查询缓存：连接建立完成后，会判断查询缓存是否开启，如果已经开启，会判断sql是select还是update/insert/delete，对于select，尝试去查询缓存，如果命中缓存直接返回数据给客户端， 如果缓存没有命中，或者没有开启缓存， 会进入到下一步分析器

4、分析器：分析器进行词法分析和语法分析，分析器先会做“词法分析”，分析SQL中的字符串分别是什么，校验数据库表和字段是否存在，然后进行语法分析，判断SQL是否满足MySQL语法

5、优化器：优化器对sql执行计划分析，得到最终执行计划，得到优化后的执行计划交给执行器

6、执行器：开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如果有权限，执行器调用存储引擎api执行sql，得到响应结果， 将结果返回给客户端，如果缓存是开启状态， 会更新缓存

7、关掉连接，释放资源
```

### MySQL的主从复制原理以及流程

```
主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行，从而使得从数据库的数据与主数据库保持一致

主从复制的作用:
	高可用和故障切换：主数据库出现问题，可以切换到从数据库。
	负载均衡：可以进行数据库层面的读写分离
	数据备份：可以在从数据库上进行日常备份
	
复制过程:()	
	主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
	从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
	从：sql执行线程——执行relay log中的语句
```

