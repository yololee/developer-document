## 事务是什么

简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一

## 事务的核心特性 ACID

InnoDB 存储引擎中的事务完全符合 ACID 的特性。ACID 是以下 4 个词的缩写：

- 原子性（atomicity）：**原子操作，即要么都做，要么都不做**
- 一致性（consistency）：**事务执行之前和执行之后都必须处于一致性状态**
- 隔离性（isolation）：**事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见**
- 持久性（durability）：**事务一旦提交，其结果就是永久性的**

## 事务的隔离级别

| 序号 | 隔离级别            | 名称     | 脏读 | 不可重复读 | 幻读 | 数据库默认隔离级别      |
| :--: | ------------------- | -------- | ---- | ---------- | ---- | ----------------------- |
|  1   | `READ  UNCOMMITTED` | 读未提交 | YES  | YES        | YES  |                         |
|  2   | `READ  COMMITTED`   | 读已提交 | NO   | YES        | YES  | `Oracle` 数据库默认级别 |
|  3   | `REPEATABLE  READ`  | 可重复读 | NO   | NO         | YES  | `MySQL` 数据库默认级别  |
|  4   | `SERIALIZABLE`      | 串行化   | NO   | NO         | NO   |                         |

## 事务带来的问题

### 脏读

脏读指的就是 **在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据**

### 不可重复读

注意分清与上面脏读的区别！！不可重复读取是一个事务对同一行数据重复读取两次但是却得到了不同结果。例如在两次读取中途有另外一个事务对该行数据进行了修改并提交，而上面的脏读是直接读取到别的事务中未提交的数据

不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些 修改操作。

因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。

这样就发生了在一个事务内两次读到的数据是不一样的情况，这种情况称为不可重复读

### 幻读

指在一个事务中多次执行相同的查询，但得到的结果集不一致。具体来说，当一个事务在某个时间点执行一个范围查询（使用WHERE条件筛选），然后在该事务内的后续查询中，由于其他并发事务的插入、删除或更新操作，结果集中出现了新的行（"幻影行"），导致了幻读现象

### 不可重复读取和幻读的区别

1. 不可重复读取（Non-repeatable Read）：在一个事务中，当某个事务多次读取同一行数据时，会发现该行数据的值发生了变化。这是由于在并发环境下，其他事务可能已经修改了这一行的数据。不可重复读通常发生在读取过程中的间隙，其中某个事务在读取数据后，另一个事务修改了该数据，并且提交了事务。这导致前一个事务再次读取相同的数据时，得到的结果不一致。
2. 幻读（Phantom Read）：在一个事务中，当某个事务多次执行相同的查询时，会发现结果集中出现了新的行或少了原本存在的行。幻读通常发生在事务的执行期间，其中某个事务在读取数据后，另一个事务插入或删除了符合前一个事务查询条件的数据，并且提交了事务。这导致前一个事务再次执行相同的查询时，得到的结果集发生了变化，出现了幻行。

总结来说，不可重复读是指同一事务中多次读取同一行数据时发现数据已被修改，而幻读是指同一事务中多次执行相同的查询时发现结果集发生了变化，出现了新增或删除的行

> - 脏读：	(读未提交) 当一个事务正在访问数据并且对数据进行修改的时候，还没有对修改的数据进行提交，然后另外一个事务访问到这个数据
> - 不可重复读： (读已提交) 指在一个事务内多处读取同一个数据，在一个事务还没有结束的时候，另外一个事务也对他进行了修改，导致了俩次读取的数据不一样。
> - 幻读： (不可重复读)   它发生在一个事务读取到了几行数据，接着另外一个事务插入了一些数据，然后第一个事务机会发现多了一些不存在的数据，跟产生了幻觉一样，称为幻读。

## 案例

### 准备数据

```mysql
create database test;
use test;
create table user(age int) engine=InnoDB;
insert into user(age) values(1);
```


### 案例：读未提交

修改隔离级别：

```mysql
set global transaction isolation level read uncommitted;
```

查看隔离级别：(这里需要断开连接后，重新连接生效)

```mysql
mysql> select @@tx_isolation;
+------------------+
| @@tx_isolation   |
+------------------+
| READ-UNCOMMITTED |
+------------------+
```

<font color = 'red'>**读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到**</font>

![image-20230711142436401](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230711142436401.png)


### 案例：读已提交

修改隔离级别：

```mysql
set global transaction isolation level read committed;
```

<font color = 'red'>**读已提交是指，一个事务提交之后，它做的变更才会被其他事务看到**</font>

![image-20230711142540560](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230711142540560.png)


### 案例：可重复读

修改隔离级别

```mysql
set global transaction isolation level repeatable read;
```

<font color = 'red'>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一 致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</font>

![image-20230711142623577](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230711142623577.png)


### 案例：串行化

修改隔离级别

```mysql
set global transaction isolation level serializable;
```

<font color = 'red'>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突 的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</font>

![image-20230711142653521](https://gitee.com/huanglei1111/phone-md/raw/master/images/image-20230711142653521.png)